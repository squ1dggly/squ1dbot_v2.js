// Keeps chats clean by preventing a user by spamming too many messages.

const clientSettings = require('../../configs/clientSettings.json');

function cacheUserChannelSpam(client, message) {
    let channelSpamCache = client.messageSpamCache.get(message.channel.id) || new Map();
    let spam = channelSpamCache.get(message.author.id) || [];

    spam.push({ content: message.content, timestamp: message.createdTimestamp });
    if (spam.length > 5) spam = spam.slice(spam.length-5, spam.length); // Doesn't let the list get longer than 5 messages

    // Updates the bot's channel cache list
    channelSpamCache.set(message.author.id, spam);
    client.messageSpamCache.set(message.channel.id, channelSpamCache);

    return {
        channelSpamCache: channelSpamCache,

        oldestMessage: (spam[0]) ? spam[0] : null,
        lastMessage: (spam[spam.length-2]) ? spam[spam.length-2] : spam[0] || null,
        newestMessage: spam[spam.length-1] || null,
        totalSpamFromUser: spam.length,
    }
}

async function sendSpamWarningMessage(client, message, spamType="true_spam") {
    var channelErrorMsgCache = client.channelErrorMsgCache.get(message.channel.id) || new Map();
    var currentSpamWarning = channelErrorMsgCache.get(`spamWarning(${message.author.id})`);

    let bullshit = () => {
        // Picks a random preset response and mentions the message author where needed
        let spam_response;

        switch (spamType) {
            case "true_spam":
                spam_response = clientSettings.ERRORMSG_NOSPAMMING[Math.floor(Math.random() * clientSettings.ERRORMSG_NOSPAMMING.length)];
            case "duplicate_spam":
                spam_response = clientSettings.ERRORMSG_NODUPLICATEMSGS[Math.floor(Math.random() * clientSettings.ERRORMSG_NODUPLICATEMSGS.length)];
            default: break;
        }

        spam_response = spam_response.replace("$$UM$$", message.author);

        // Sends the spam warning message to the channel
        message.channel.send(spam_response)
            .then(msg => { currentSpamWarning = msg; setTimeout(() => msg.delete(), clientSettings.MSGTIMEOUT_SPAMWARNING) });

        // Caches our new current spam warning message
        channelErrorMsgCache.set(message.channel.id, currentSpamWarning);
        client.channelErrorMsgCache.set(message.channel.id, channelErrorMsgCache);

        console.log(currentSpamWarning);
    }

    if (currentSpamWarning) {
        if (currentSpamWarning.createdTimestamp > clientSettings.MSGTIMEOUT_SPAMWARNING)
            return bullshit();
    }
    else {
        return bullshit();
    }
}

module.exports = {
    name: "Manage Spam",
    event: "messageCreate",

    execute: async (client, message) => {
        if (message.author.id === client.user.id) return;

        let userSpam = cacheUserChannelSpam(client, message);
        
        // If the user sends multiple messages within a short amount of time delete it:
        let messageTimestampDifference = userSpam.newestMessage.timestamp - userSpam.oldestMessage.timestamp;

        if (userSpam.totalSpamFromUser >= 3 && messageTimestampDifference < clientSettings.MSGTIMEOUT_SPAM) {
            message.delete();

            try { return sendSpamWarningMessage(client, message, "true_spam"); } catch { return; };
        }

        // If the user sends more than 1 of the exact same message in the same channel and within a short amount of time delete it:
        let timeDifferenceFromLastMessage = userSpam.newestMessage.timestamp - userSpam.lastMessage.timestamp;

        if (userSpam.totalSpamFromUser >= 2 && userSpam.newestMessage.content === userSpam.lastMessage.content && timeDifferenceFromLastMessage < 5000) {
            message.delete();

            try { return sendSpamWarningMessage(client, message, "duplicate_spam"); } catch { return; };
        }
    }
}